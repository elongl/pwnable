'''
This binary has both NX bit enabled,
which means code on the stack cannot be executed,
So I can't pass a shellcode and jump do it.
And canary enabled, which means I can't invoke a buffer overflow within the stack.

One of the ways to overcome this is to gain control of the stack,
and by doing so we can jump to certain functions that are already in the `.text` section (executable).

Ideally what we'd do is set the register according to our needs (SYS_EXECVE, '/bin/sh'),
and then jump to an `int 0x80` instruction.

I noticed that when summing up two very large numbers (INT_MAX) for instance,
there's an integer overflow and I get invalid results, most likely this is what the challenge is about.

Notes:
    - Allocated memory for operands is never freed.
    - Is there a way to exploit the integer overflow?


After quite a lot of time,
I analyzed the program deeply and still couldn't find the vulnerability.
What I decided to do is leave IDA "alone" and start thinking about how I'd implement a calculator,
and what could possibly go wrong in the process.
'''

from pwn import *

p = gdb.debug(
    './calc',
    '''
    b *(parse_expr+0x196)
    c
    '''
)
p.writeline('+'.join(['1'] * 513))
p.writeline('1337+6969')
p.writeline('1337+6969-888')
p.writeline(f'{2 ** 32}+2')


# Fuzzing
p = process('./calc')


# The multiplier is the maximum value to which you get the right result plus one.
p.writeline('+'.join(['1'] * 513))
# 'expression error!\n0\n'

p.writeline('+'.join(['11'] * 1025))
# '3752\n3752\nexpression error!\n0\n'

p.writeline('+'.join(['111'] * 257))
# 'expression error!\n0\n'

p.writeline('+'.join(['1111'] * 1025))
# '227755\n708682399\n226656\n226656\nexpression error!\n0\n'

# Weird patterns.